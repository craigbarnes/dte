// Escape sequence parser for xterm function keys.
// Copyright 2018 Craig Barnes.
// SPDX-License-Identifier: GPL-2.0-only
// Generated by: src/lookup/xterm-keys.lua
// See also: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html

#include <sys/types.h>
#include "../key.h"

static ssize_t parse_xterm_key_sequence(const char *buf, size_t length, Key *k)
{
    if (length == 0 || buf[0] != '\033') {
        return 0;
    }
    size_t i = 1;
    if (i >= length) return -1;
    switch(buf[i++]) {
    case 'O':
        if (i >= length) return -1;
        switch(buf[i++]) {
        case ' ':
            *k = ' ';
            return i;
        case 'A':
            *k = KEY_UP;
            return i;
        case 'B':
            *k = KEY_DOWN;
            return i;
        case 'C':
            *k = KEY_RIGHT;
            return i;
        case 'D':
            *k = KEY_LEFT;
            return i;
        case 'F':
            *k = KEY_END;
            return i;
        case 'H':
            *k = KEY_HOME;
            return i;
        case 'I':
            *k = '\t';
            return i;
        case 'M':
            *k = '\r';
            return i;
        case 'P':
            *k = KEY_F1;
            return i;
        case 'Q':
            *k = KEY_F2;
            return i;
        case 'R':
            *k = KEY_F3;
            return i;
        case 'S':
            *k = KEY_F4;
            return i;
        case 'j':
            *k = '*';
            return i;
        case 'k':
            *k = '+';
            return i;
        case 'm':
            *k = '-';
            return i;
        case 'o':
            *k = '/';
            return i;
        }
        return 0;
    case '[':
        if (i >= length) return -1;
        switch(buf[i++]) {
        case '1':
            if (i >= length) return -1;
            switch(buf[i++]) {
            case '1':
                *k = KEY_F1;
                goto check_trailing_tilde;
            case '2':
                *k = KEY_F2;
                goto check_trailing_tilde;
            case '3':
                *k = KEY_F3;
                goto check_trailing_tilde;
            case '4':
                *k = KEY_F4;
                goto check_trailing_tilde;
            case '5':
                *k = KEY_F5;
                goto check_trailing_tilde;
            case '7':
                *k = KEY_F6;
                goto check_trailing_tilde;
            case '8':
                *k = KEY_F7;
                goto check_trailing_tilde;
            case '9':
                *k = KEY_F8;
                goto check_trailing_tilde;
            case ';':
                if (i >= length) return -1;
                switch(buf[i++]) {
                case '2':
                    if (i >= length) return -1;
                    switch(buf[i++]) {
                    case 'A':
                        *k = MOD_SHIFT | KEY_UP;
                        return i;
                    case 'B':
                        *k = MOD_SHIFT | KEY_DOWN;
                        return i;
                    case 'C':
                        *k = MOD_SHIFT | KEY_RIGHT;
                        return i;
                    case 'D':
                        *k = MOD_SHIFT | KEY_LEFT;
                        return i;
                    case 'F':
                        *k = MOD_SHIFT | KEY_END;
                        return i;
                    case 'H':
                        *k = MOD_SHIFT | KEY_HOME;
                        return i;
                    }
                    return 0;
                case '3':
                    if (i >= length) return -1;
                    switch(buf[i++]) {
                    case 'A':
                        *k = MOD_META | KEY_UP;
                        return i;
                    case 'B':
                        *k = MOD_META | KEY_DOWN;
                        return i;
                    case 'C':
                        *k = MOD_META | KEY_RIGHT;
                        return i;
                    case 'D':
                        *k = MOD_META | KEY_LEFT;
                        return i;
                    case 'F':
                        *k = MOD_META | KEY_END;
                        return i;
                    case 'H':
                        *k = MOD_META | KEY_HOME;
                        return i;
                    }
                    return 0;
                case '4':
                    if (i >= length) return -1;
                    switch(buf[i++]) {
                    case 'A':
                        *k = MOD_SHIFT | MOD_META | KEY_UP;
                        return i;
                    case 'B':
                        *k = MOD_SHIFT | MOD_META | KEY_DOWN;
                        return i;
                    case 'C':
                        *k = MOD_SHIFT | MOD_META | KEY_RIGHT;
                        return i;
                    case 'D':
                        *k = MOD_SHIFT | MOD_META | KEY_LEFT;
                        return i;
                    case 'F':
                        *k = MOD_SHIFT | MOD_META | KEY_END;
                        return i;
                    case 'H':
                        *k = MOD_SHIFT | MOD_META | KEY_HOME;
                        return i;
                    }
                    return 0;
                case '5':
                    if (i >= length) return -1;
                    switch(buf[i++]) {
                    case 'A':
                        *k = MOD_CTRL | KEY_UP;
                        return i;
                    case 'B':
                        *k = MOD_CTRL | KEY_DOWN;
                        return i;
                    case 'C':
                        *k = MOD_CTRL | KEY_RIGHT;
                        return i;
                    case 'D':
                        *k = MOD_CTRL | KEY_LEFT;
                        return i;
                    case 'F':
                        *k = MOD_CTRL | KEY_END;
                        return i;
                    case 'H':
                        *k = MOD_CTRL | KEY_HOME;
                        return i;
                    }
                    return 0;
                case '6':
                    if (i >= length) return -1;
                    switch(buf[i++]) {
                    case 'A':
                        *k = MOD_SHIFT | MOD_CTRL | KEY_UP;
                        return i;
                    case 'B':
                        *k = MOD_SHIFT | MOD_CTRL | KEY_DOWN;
                        return i;
                    case 'C':
                        *k = MOD_SHIFT | MOD_CTRL | KEY_RIGHT;
                        return i;
                    case 'D':
                        *k = MOD_SHIFT | MOD_CTRL | KEY_LEFT;
                        return i;
                    case 'F':
                        *k = MOD_SHIFT | MOD_CTRL | KEY_END;
                        return i;
                    case 'H':
                        *k = MOD_SHIFT | MOD_CTRL | KEY_HOME;
                        return i;
                    }
                    return 0;
                case '7':
                    if (i >= length) return -1;
                    switch(buf[i++]) {
                    case 'A':
                        *k = MOD_META | MOD_CTRL | KEY_UP;
                        return i;
                    case 'B':
                        *k = MOD_META | MOD_CTRL | KEY_DOWN;
                        return i;
                    case 'C':
                        *k = MOD_META | MOD_CTRL | KEY_RIGHT;
                        return i;
                    case 'D':
                        *k = MOD_META | MOD_CTRL | KEY_LEFT;
                        return i;
                    case 'F':
                        *k = MOD_META | MOD_CTRL | KEY_END;
                        return i;
                    case 'H':
                        *k = MOD_META | MOD_CTRL | KEY_HOME;
                        return i;
                    }
                    return 0;
                case '8':
                    if (i >= length) return -1;
                    switch(buf[i++]) {
                    case 'A':
                        *k = MOD_SHIFT | MOD_META | MOD_CTRL | KEY_UP;
                        return i;
                    case 'B':
                        *k = MOD_SHIFT | MOD_META | MOD_CTRL | KEY_DOWN;
                        return i;
                    case 'C':
                        *k = MOD_SHIFT | MOD_META | MOD_CTRL | KEY_RIGHT;
                        return i;
                    case 'D':
                        *k = MOD_SHIFT | MOD_META | MOD_CTRL | KEY_LEFT;
                        return i;
                    case 'F':
                        *k = MOD_SHIFT | MOD_META | MOD_CTRL | KEY_END;
                        return i;
                    case 'H':
                        *k = MOD_SHIFT | MOD_META | MOD_CTRL | KEY_HOME;
                        return i;
                    }
                    return 0;
                }
                return 0;
            case '~':
                *k = KEY_HOME;
                return i;
            }
            return 0;
        case '2':
            if (i >= length) return -1;
            switch(buf[i++]) {
            case '0':
                *k = KEY_F9;
                goto check_trailing_tilde;
            case '1':
                *k = KEY_F10;
                goto check_trailing_tilde;
            case '3':
                *k = KEY_F11;
                goto check_trailing_tilde;
            case '4':
                *k = KEY_F12;
                goto check_trailing_tilde;
            case ';':
                if (i >= length) return -1;
                switch(buf[i++]) {
                case '2':
                    *k = MOD_SHIFT | KEY_INSERT;
                    goto check_trailing_tilde;
                case '3':
                    *k = MOD_META | KEY_INSERT;
                    goto check_trailing_tilde;
                case '4':
                    *k = MOD_SHIFT | MOD_META | KEY_INSERT;
                    goto check_trailing_tilde;
                case '5':
                    *k = MOD_CTRL | KEY_INSERT;
                    goto check_trailing_tilde;
                case '6':
                    *k = MOD_SHIFT | MOD_CTRL | KEY_INSERT;
                    goto check_trailing_tilde;
                case '7':
                    *k = MOD_META | MOD_CTRL | KEY_INSERT;
                    goto check_trailing_tilde;
                case '8':
                    *k = MOD_SHIFT | MOD_META | MOD_CTRL | KEY_INSERT;
                    goto check_trailing_tilde;
                }
                return 0;
            case '~':
                *k = KEY_INSERT;
                return i;
            }
            return 0;
        case '3':
            if (i >= length) return -1;
            switch(buf[i++]) {
            case ';':
                if (i >= length) return -1;
                switch(buf[i++]) {
                case '2':
                    *k = MOD_SHIFT | KEY_DELETE;
                    goto check_trailing_tilde;
                case '3':
                    *k = MOD_META | KEY_DELETE;
                    goto check_trailing_tilde;
                case '4':
                    *k = MOD_SHIFT | MOD_META | KEY_DELETE;
                    goto check_trailing_tilde;
                case '5':
                    *k = MOD_CTRL | KEY_DELETE;
                    goto check_trailing_tilde;
                case '6':
                    *k = MOD_SHIFT | MOD_CTRL | KEY_DELETE;
                    goto check_trailing_tilde;
                case '7':
                    *k = MOD_META | MOD_CTRL | KEY_DELETE;
                    goto check_trailing_tilde;
                case '8':
                    *k = MOD_SHIFT | MOD_META | MOD_CTRL | KEY_DELETE;
                    goto check_trailing_tilde;
                }
                return 0;
            case '~':
                *k = KEY_DELETE;
                return i;
            }
            return 0;
        case '4':
            *k = KEY_END;
            goto check_trailing_tilde;
        case '5':
            if (i >= length) return -1;
            switch(buf[i++]) {
            case ';':
                if (i >= length) return -1;
                switch(buf[i++]) {
                case '2':
                    *k = MOD_SHIFT | KEY_PAGE_UP;
                    goto check_trailing_tilde;
                case '3':
                    *k = MOD_META | KEY_PAGE_UP;
                    goto check_trailing_tilde;
                case '4':
                    *k = MOD_SHIFT | MOD_META | KEY_PAGE_UP;
                    goto check_trailing_tilde;
                case '5':
                    *k = MOD_CTRL | KEY_PAGE_UP;
                    goto check_trailing_tilde;
                case '6':
                    *k = MOD_SHIFT | MOD_CTRL | KEY_PAGE_UP;
                    goto check_trailing_tilde;
                case '7':
                    *k = MOD_META | MOD_CTRL | KEY_PAGE_UP;
                    goto check_trailing_tilde;
                case '8':
                    *k = MOD_SHIFT | MOD_META | MOD_CTRL | KEY_PAGE_UP;
                    goto check_trailing_tilde;
                }
                return 0;
            case '~':
                *k = KEY_PAGE_UP;
                return i;
            }
            return 0;
        case '6':
            if (i >= length) return -1;
            switch(buf[i++]) {
            case ';':
                if (i >= length) return -1;
                switch(buf[i++]) {
                case '2':
                    *k = MOD_SHIFT | KEY_PAGE_DOWN;
                    goto check_trailing_tilde;
                case '3':
                    *k = MOD_META | KEY_PAGE_DOWN;
                    goto check_trailing_tilde;
                case '4':
                    *k = MOD_SHIFT | MOD_META | KEY_PAGE_DOWN;
                    goto check_trailing_tilde;
                case '5':
                    *k = MOD_CTRL | KEY_PAGE_DOWN;
                    goto check_trailing_tilde;
                case '6':
                    *k = MOD_SHIFT | MOD_CTRL | KEY_PAGE_DOWN;
                    goto check_trailing_tilde;
                case '7':
                    *k = MOD_META | MOD_CTRL | KEY_PAGE_DOWN;
                    goto check_trailing_tilde;
                case '8':
                    *k = MOD_SHIFT | MOD_META | MOD_CTRL | KEY_PAGE_DOWN;
                    goto check_trailing_tilde;
                }
                return 0;
            case '~':
                *k = KEY_PAGE_DOWN;
                return i;
            }
            return 0;
        case 'A':
            *k = KEY_UP;
            return i;
        case 'B':
            *k = KEY_DOWN;
            return i;
        case 'C':
            *k = KEY_RIGHT;
            return i;
        case 'D':
            *k = KEY_LEFT;
            return i;
        case 'F':
            *k = KEY_END;
            return i;
        case 'H':
            *k = KEY_HOME;
            return i;
        case 'L':
            *k = KEY_INSERT;
            return i;
        case 'Z':
            *k = MOD_SHIFT | '\t';
            return i;
        case '[':
            if (i >= length) return -1;
            switch(buf[i++]) {
            case 'A':
                *k = KEY_F1;
                return i;
            case 'B':
                *k = KEY_F2;
                return i;
            case 'C':
                *k = KEY_F3;
                return i;
            case 'D':
                *k = KEY_F4;
                return i;
            case 'E':
                *k = KEY_F5;
                return i;
            }
            return 0;
        }
        return 0;
    }
    return 0;
check_trailing_tilde:
    if (i >= length) {
        return -1;
    } else if (buf[i++] == '~') {
        return i;
    }
    return 0;
}
